# Assignment-1-Fundamentals-of-Software-Testing

1. Importance of Software Testing in Software Development

Software testing is a critical phase in the software development lifecycle. It ensures that a system meets its requirements, works as expected, and delivers a quality experience to the user. By testing thoroughly, developers can catch issues early, minimize risks, and reduce costs associated with fixing bugs later in production. Ultimately, software testing is not just about finding faults — it's about building confidence in the product.

2. Key Testing Concepts: Error, Defect, and Failure

Error: A human mistake made by a developer during code writing or system design. For example, a miscalculated formula or wrong logic flow.

Defect (Bug): A flaw in the software caused by an error. It might not be visible until the program is executed. It's what the testers find and log.

Failure: The visible result of a defect when the software doesn't behave as expected during execution. For instance, the system crashes or gives incorrect output.

These three are interconnected — an error leads to a defect, and when that defect is executed, it may cause a failure.

3. Principles of Software Testing: The Pesticide Paradox

The Pesticide Paradox suggests that running the same set of tests repeatedly will not uncover new bugs. Just like pests become resistant to the same pesticide, software might pass the same tests even though new bugs exist.To overcome this, test cases must be regularly reviewed, updated, and diversified. This ensures we’re testing from fresh angles and not becoming blind to hidden defects.

4. Types of Testing Methodologies: Static vs Dynamic Testing

Static Testing: Involves examining code, documentation, and requirements without executing the program. This includes code reviews, walkthroughs, and inspections. It’s useful for catching syntax errors or design flaws early.

Dynamic Testing: Involves executing the code and observing its behavior. This helps detect issues related to performance, functionality, and runtime errors. Examples include unit testing, integration testing, and system testing.

Both types complement each other — static testing improves code quality early, while dynamic testing verifies behavior during execution.

5. The Impact of Early Testing in the SDLC

Testing early — right from the requirements and design phase — prevents issues from snowballing into costly bugs later. This is known as Shift-Left Testing.Early testing helps:

Identify ambiguous or incomplete requirements

Avoid design flaws

Reduce rework during coding

Save time and resources during the final stages

By making testing a continuous process instead of a final step, teams can deliver faster, better, and more reliable software.

